#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
The MiniWeather Mini App
\end_layout

\begin_layout Author
Matt Norman, Oak Ridge National Laboratory
\end_layout

\begin_layout Date
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The miniWeather code mimics the basic dynamics seen in atmospheric weather
 and climate.
 The dynamics themselves are dry compressible, stratified, non-hydrostatic
 flows dominated by buoyant forces that are relatively small perturbations
 on a hydrostatic background state.
 The equations in this code themselves form the backbone of pretty much
 all fluid dynamics codes, and this particular flavor forms the base of
 all weather and climate modeling.
\end_layout

\begin_layout Standard
With about 500 total lines of code (and only about 200 lines that you care
 about), it serves as an approachable place to learn parallelization and
 porting using MPI + X, where X is OpenMP, OpenACC, CUDA, or potentially
 other approaches to CPU and accelerated parallelization.
 The code uses periodic boundary conditions in the 
\begin_inset Formula $x$
\end_inset

-direction and solid wall boundary conditions in the 
\begin_inset Formula $z$
\end_inset

-direction.
 
\end_layout

\begin_layout Section
Compiling and Running the Code
\end_layout

\begin_layout Subsection
Required Libraries
\end_layout

\begin_layout Standard
To run everything in this code, you need MPI, parallel-netcdf, ncview, and
 an OpenACC compiler (preferably PGI 17+) to be installed.
 The serial code still uses MPI because I figured it was best to start with
 parallel I/O in place so that it's ready to go when the MPI implementation
 is done.
 
\end_layout

\begin_layout Standard
You can download parallel-netcdf from:
\begin_inset Newline newline
\end_inset


\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://trac.mcs.anl.gov/projects/parallel-netcdf
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

Also, you can download a free version of PGI Community Edition (which has
 OpenACC implemented) from:
\begin_inset Newline newline
\end_inset


\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.pgroup.com/products/community.htm
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

You'll probably also want to have 
\begin_inset Quotes eld
\end_inset

ncview
\begin_inset Quotes erd
\end_inset

 installed so you can easily view the NetCDF files.
 Ncview also makes it easy to see a movie of the solution as it evolves
 in time:
\begin_inset Newline newline
\end_inset


\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://meteora.ucsd.edu/~pierce/ncview_home_page.html
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Directories and Compiling
\end_layout

\begin_layout Standard
There are three main directories in the mini app: (1) a Fortran source directory
; (2) a C source directory; and (3) a documentation directory, which you
 presumably know about because it contains this text you're reading now.
 The C code is technically C++ code but only because I wanted to use the
 ampersand pass by reference notation because C's endless asterisks make
 me want to die.
 I kept the code from C++ proper because it makes OpenACC and OpenMP 4.5
 easier to use, though multidimensional array indexing in C is certainly
 cumbersome.
\end_layout

\begin_layout Standard
To compile the code, first edit the Makefile and change the flags to point
 to your parallel-netcdf installation as well as change the flags based
 on which compiler you are using.
 There are four versions of the code: serial, mpi, mpi+openmp, and mpi+openacc.
 The filenames make it clear which file is associated with which programming
 paradigm.
 To make all of these at once, simply type 
\begin_inset Quotes eld
\end_inset

make
\begin_inset Quotes erd
\end_inset

.
 To make them individually, you can type 
\begin_inset Quotes eld
\end_inset

make serial
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

make mpi
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

make openmp
\begin_inset Quotes erd
\end_inset

, and 
\begin_inset Quotes eld
\end_inset

make openacc
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection
Altering the Code's Configurations
\end_layout

\begin_layout Standard
There are four aspects of the configuration you can edit easily, and they
 are clearly labeled in the code as 
\begin_inset Quotes eld
\end_inset

USER-CONFIGURABLE PARAMETERS
\begin_inset Quotes erd
\end_inset

.
 These include: (1) the number of cells to use [
\begin_inset Quotes eld
\end_inset

nx_glob
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

nz_glob
\begin_inset Quotes erd
\end_inset

]; (2) the amount of time to simulation [
\begin_inset Quotes eld
\end_inset

sim_time
\begin_inset Quotes erd
\end_inset

]; (3) the frequency to output data to file [
\begin_inset Quotes eld
\end_inset

output_freq
\begin_inset Quotes erd
\end_inset

]; and (4) the initial data to use [
\begin_inset Quotes eld
\end_inset

data_spec_int
\begin_inset Quotes erd
\end_inset

].
 
\end_layout

\begin_layout Subsection
Running the Code
\end_layout

\begin_layout Standard
To run the code, simply call 
\begin_inset Quotes eld
\end_inset

mpirun -n [# ranks] ./mini_weather_[version]
\begin_inset Quotes erd
\end_inset

.
 Since parameters are set in the code itself, you don't need to pass any
 parameters.
 Some machines use different tools instead of mpirun (e.g., OLCF's Titan uses
 
\begin_inset Quotes eld
\end_inset

aprun
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Subsection
Viewing the Output
\end_layout

\begin_layout Standard
The file I/O is done in the netCDF format: (
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.unidata.ucar.edu/software/netcdf/
\end_layout

\end_inset

).
 To me, the easiest way to view the data is to use a tool called 
\begin_inset Quotes eld
\end_inset

ncview
\begin_inset Quotes erd
\end_inset

 (
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://meteora.ucsd.edu/~pierce/ncview_home_page.html
\end_layout

\end_inset

).
 To use it, you can simply type 
\begin_inset Quotes eld
\end_inset

ncview output.nc
\begin_inset Quotes erd
\end_inset

, making sure you have X-forwarding enabled in your ssh session.
 Further, you can call 
\begin_inset Quotes eld
\end_inset

ncview -frames output.nc
\begin_inset Quotes erd
\end_inset

, and it will dump out all of your frames in the native resolution you're
 viewing the data in, and you you can render a movie with tools like ffmpeg.
 
\end_layout

\begin_layout Section
Parallelization
\end_layout

\begin_layout Standard
This code was designed to parallelize with MPI first and then OpenMP or
 OpenACC next, but you can always parallelize with OpenMP or OpenACC without
 MPI if you want.
 But it is rewarding to be able to run it on multiple nodes at higher resolution
 for more and sharper eddies in the dynamics.
 
\end_layout

\begin_layout Standard
As you port the code, you'll want to change relatively little code at a
 time, re-compile, re-run, and look at the output to see that you're still
 getting the right answer.
 There are advantages to using a visual tool to check the answer, as it
 can sometimes give you clues as to why you're not getting the right answer.
 
\end_layout

\begin_layout Standard
Note that you only need to make changes code within the first 450 source
 lines.
 Everything below that is initialization and I/O code that doesn't need
 to be parallelized (unless you want to).
 There's a note in the serial code that tells you at what point the rest
 of the code will remain the same, even after parallelization.
\end_layout

\begin_layout Subsection
Indexing
\end_layout

\begin_layout Standard
The code makes room for so-called 
\begin_inset Quotes eld
\end_inset

halo
\begin_inset Quotes erd
\end_inset

 cells in the fluid state.
 This is a common practice in any algorithm that uses stencil-based reconstructi
on to estimate variation within a domain.
 In this code, there are 
\begin_inset Quotes eld
\end_inset

hs
\begin_inset Quotes erd
\end_inset

 halo cells on either side of each dimension, and I pretty much hard-code
 hs=2.
\end_layout

\begin_layout Standard
In the Fortran code, the x- and z-dimensions are dimensioned as multi-dimensiona
l arrays that range from 1-hs:nx+hs.
 In the x-direction, 1-hs:0 belong to the MPI task to the left, cells 1:nx
 belong to the current MPI task, and nx+1:nx+hs belong to the MPI task to
 the right.
 In the z-dimension, 1-hs:0 are artificially set to mimic a solid wall boundary
 condition at the bottom, and nz+1:nz+hs are the same for the top boundary.
\end_layout

\begin_layout Standard
In the C code, the fluid state array is dimensioned to size (nz+2*hs) and
 (nx+2*hs) in the x- and z-directions.
 In the x-direction, cells 0 to hs-1 belong to the left MPI task, cells
 hs to nx+hs-1 belong to the current MPI taks, and cells nx+hs to nx+2*hs-1
 belong to the right MPI task.
 The z-direction's halo cells are used to mimic solid wall boundaries.
\end_layout

\begin_layout Standard
Since the code is periodic, the 
\begin_inset Quotes eld
\end_inset

left
\begin_inset Quotes erd
\end_inset

 MPI task will wrap around the domain if you are task zero, and the 
\begin_inset Quotes eld
\end_inset

right
\begin_inset Quotes erd
\end_inset

 MPI task will wrap around the domain if you are task 
\begin_inset Quotes eld
\end_inset

nranks-1
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Subsection
MPI
\end_layout

\begin_layout Standard
This code was designed to use domain decomposition, where each MPI rank
 
\begin_inset Quotes eld
\end_inset

owns
\begin_inset Quotes erd
\end_inset

 a certain set of cells in the x-direction and contains two 
\begin_inset Quotes eld
\end_inset

halo
\begin_inset Quotes erd
\end_inset

 cells from the left- and right-had MPI tasks in the x-direction as well.
 The domain is only decomposed in the 
\begin_inset Formula $x$
\end_inset

-direction and not the 
\begin_inset Formula $z$
\end_inset

-direction.
\end_layout

\begin_layout Standard
IMPORTANT: Please be sure to set 
\begin_inset Quotes eld
\end_inset

nranks
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

myrank
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

nx
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

i_beg
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

left_rank
\begin_inset Quotes erd
\end_inset

, and 
\begin_inset Quotes eld
\end_inset

right_rank
\begin_inset Quotes erd
\end_inset

.
 These are clearly marked in the serial source code.
 You can set more variables, but these are used elsewhere in the code (particula
rly in the parallel file I/O), so they must be set.
\end_layout

\begin_layout Standard
To parallelize with MPI, there are only two places in the code that need
 to be altered.
 The first is the initialization, a subroutine / function named 
\begin_inset Quotes eld
\end_inset

init
\begin_inset Quotes erd
\end_inset

, where you must determine the number of ranks, you process's rank, the
 beginning index of your rank's first cell in the x-direction, the number
 of x-direction cells your rank will own, and the MPI rank IDs that are
 to your left and your right.
 Because the code is periodic in the 
\begin_inset Formula $x$
\end_inset

-direction, your left and right neighboring ranks will wrap around.
 For instance, if your are rank zero, your left-most rank will be nranks-1.
\end_layout

\begin_layout Standard
The second place is in the routine that sets the halo values in the 
\begin_inset Formula $x$
\end_inset

-direction.
 In this routine, you need to:
\end_layout

\begin_layout Enumerate
Create MPI data buffers (at the same place the other arrays are declared)
 to hold the data that needs to be sent and received, allocate them in the
 init() routine, and deallocate them in the finalize() routine.
\end_layout

\begin_layout Enumerate
Pack the data you need to send to your left and right MPI neighbors
\end_layout

\begin_layout Enumerate
Send the data to your left and right MPI neighbors
\end_layout

\begin_layout Enumerate
Receive the data from your left and right MPI neighbors
\end_layout

\begin_layout Enumerate
Unpack the data from your left and right neighbors and place the data into
 your MPI rank's halo cells.
 
\end_layout

\begin_layout Standard
Once you complete this, the code will be fully parallelized in MPI.
 Both of the places you need to add code for MPI are marked in the serial
 code, and there are some extra hints in the 
\begin_inset Quotes eld
\end_inset

set_halo_values_x()
\begin_inset Quotes erd
\end_inset

 routine as well.
\end_layout

\begin_layout Subsection
OpenMP
\end_layout

\begin_layout Standard
For the OpenMP code, you basically need to decorate the loops with 
\begin_inset Quotes eld
\end_inset

omp parallel do
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

omp parallel for
\begin_inset Quotes erd
\end_inset

 and pay attention to any variables you need to make 
\begin_inset Quotes eld
\end_inset

private
\begin_inset Quotes erd
\end_inset

 so that each thread has its own copy.
 Keep in mind that OpenMP works best on 
\begin_inset Quotes eld
\end_inset

outer
\begin_inset Quotes erd
\end_inset

 loops rather than 
\begin_inset Quotes eld
\end_inset

inner
\begin_inset Quotes erd
\end_inset

 loops.
 Also, for sake of performance, there are a couple of instances where it
 is wise to use the 
\begin_inset Quotes eld
\end_inset

collapse
\begin_inset Quotes erd
\end_inset

 clause because the outermost loop is not large enough to support the number
 of threads most CPUs have.
\end_layout

\begin_layout Subsection
OpenACC
\end_layout

\begin_layout Standard
The OpenACC approach will differ depending on whether you're in Fortran
 or C.
 Just a forewarning, OpenACC is much more convenient in Fortran when it
 comes to data movement because in Fortran, the compiler knows how big your
 arrays are, and therefore the compiler can (and does) create all of the
 data movement for you.
 All you have to do is optimize the data movement after the fact.
\end_layout

\begin_layout Subsubsection
Fortran Code
\end_layout

\begin_layout Standard
The OpenACC parallelization is a bit more involved when it comes to performance.
 But, it's a good idea to just start with the kernels themselves, since
 the compiler will generate all of your data statements for you on a per-kernel
 basis.
 You need to pay attention to private variables here as well.
\end_layout

\begin_layout Standard
Once you're getting the right answer with the kernels on the GPU, you can
 look at optimizing data movement by putting in data statements.
 I recommend putting data statements for the state, tend, flux, hy_*, and
 the MPI buffers around the main time stepping loop.
 Then, you need to move the data to the host before sending MPI data, back
 to the device once you receive MPI data, and to the host before file I/O.
\end_layout

\begin_layout Subsubsection
C/C++
\end_layout

\begin_layout Standard
To be written.
\end_layout

\begin_layout Section
Numerical Experiments
\end_layout

\begin_layout Standard
A number of numerical experiments are in the code for you to play around
 with.
 You can set these by changing the 
\begin_inset Quotes eld
\end_inset

data_spec_int
\begin_inset Quotes erd
\end_inset

 variable.
 
\end_layout

\begin_layout Subsection
Rising Thermal
\end_layout

\begin_layout Standard
data_spec_int = DATA_SPEC_THERMAL
\begin_inset Newline newline
\end_inset

sim_time = 1000
\begin_inset Newline newline
\end_inset

This simulates a rising thermal in a neutral atmosphere, which will look
 something like a 
\begin_inset Quotes eld
\end_inset

mushroom
\begin_inset Quotes erd
\end_inset

 cloud (without all of the subsequent violence).
\end_layout

\begin_layout Subsection
Colliding Thermals
\end_layout

\begin_layout Standard
data_spec_int == DATA_SPEC_COLLISION
\begin_inset Newline newline
\end_inset

sim_time = 600
\begin_inset Newline newline
\end_inset

This is similar to the rising thermal test case except with a cold bubble
 at the model top colliding with a warm bubble at the model bottom to produce
 some cool looking eddies.
\end_layout

\begin_layout Subsection
Mountain Gravity Waves
\end_layout

\begin_layout Standard
data_spec_int == DATA_SPEC_MOUNTAIN
\begin_inset Newline newline
\end_inset

sim_time = 1500
\begin_inset Newline newline
\end_inset

This test cases passes a horizontal wind over a faked mountain at the model
 bottom in a stable atmosphere to generate a train of stationary gravity
 waves across the model domain.
\end_layout

\begin_layout Subsection
Turbulence
\end_layout

\begin_layout Standard
data_spec_int == DATA_SPEC_TURBULENCE
\begin_inset Newline newline
\end_inset

sim_time = 1000
\begin_inset Newline newline
\end_inset

This test case creates a neutrally stratified atmosphere with randomly initializ
e winds.
 After a few time steps, the random noise is locally averaged out to lower
 values.
 Keep in mind that this is not classic turbulence in any sense because it's
 only 2-D, and it's stratified.
\end_layout

\begin_layout Subsection
Density Current
\end_layout

\begin_layout Standard
data_spec_int == DATA_SPEC_DENSITY_CURRENT
\begin_inset Newline newline
\end_inset

sim_time = 600
\begin_inset Newline newline
\end_inset

This test case creates a neutrally stratified atmosphere with a strong cold
 bubble in the middle of the domain that crashes into the ground to give
 the feel of a weather front (more of a downburst, really).
\end_layout

\begin_layout Section
Physics and Numerical Approximation
\end_layout

\begin_layout Standard
While these numerics are certainly cheap and dirty, they are probably the
 fastest way to get the job done at a moderate order of accuracy.
 For instance, on 16 K20x GPUs, you can perform a simulation with 5 million
 grid cells (3200 
\begin_inset Formula $\times$
\end_inset

 1600) in just a few minutes.
\end_layout

\begin_layout Subsection
The 2-D Euler Equations
\end_layout

\begin_layout Standard
This app simulates the 2-D inviscid Euler equations for stratified fluid
 dynamics, which are defined as follows: 
\begin_inset Formula 
\begin{equation}
\frac{\partial}{\partial t}\left[\begin{array}{c}
\rho\\
\rho u\\
\rho w\\
\rho\theta
\end{array}\right]+\frac{\partial}{\partial x}\left[\begin{array}{c}
\rho u\\
\rho u^{2}+p\\
\rho uw\\
\rho u\theta
\end{array}\right]+\frac{\partial}{\partial z}\left[\begin{array}{c}
\rho w\\
\rho wu\\
\rho w^{2}+p\\
\rho w\theta
\end{array}\right]=\left[\begin{array}{c}
0\\
0\\
-\rho g\\
0
\end{array}\right]\label{eq:equations_spelled_out}
\end{equation}

\end_inset


\begin_inset Formula 
\[
\rho_{H}=-\frac{1}{g}\frac{\partial p}{\partial z}
\]

\end_inset

where 
\begin_inset Formula $\rho$
\end_inset

 is density, 
\begin_inset Formula $u$
\end_inset

, and 
\begin_inset Formula $w$
\end_inset

 are winds in the 
\begin_inset Formula $x$
\end_inset

-, and 
\begin_inset Formula $z$
\end_inset

-directions, respectively, 
\begin_inset Formula $\theta$
\end_inset

 is potential temperature related to temperature, 
\begin_inset Formula $T$
\end_inset

, by 
\begin_inset Formula $\theta=T\left(P_{0}/P\right)^{R_{d}/c_{p}}$
\end_inset

, 
\begin_inset Formula $P_{0}=10^{5}\,\text{Pa}$
\end_inset

, 
\begin_inset Formula $g=9.8\text{\,\ m}\,\mbox{s}^{-2}$
\end_inset

 is acceleration due to gravity, 
\begin_inset Formula $p=C_{0}\left(\rho\theta\right)^{\gamma}$
\end_inset

 is pressure, 
\begin_inset Formula $C_{0}=R_{d}^{\gamma}p_{0}^{-R_{d}/c_{v}}$
\end_inset

, 
\begin_inset Formula $R_{d}=287\,\mbox{J}\,\mbox{kg}^{-1}\,\mbox{K}^{-1}$
\end_inset

, 
\begin_inset Formula $\gamma=c_{p}/c_{v}$
\end_inset

, 
\begin_inset Formula $c_{p}=1004\,\mbox{J}\,\mbox{kg}^{-1}\,\mbox{K}^{-1}$
\end_inset

, 
\begin_inset Formula $c_{v}=717\,\mbox{J}\,\mbox{kg}^{-1}\,\mbox{K}^{-1}$
\end_inset

, and 
\begin_inset Formula $p_{0}=10^{5}\,\mbox{Pa}$
\end_inset

.
 This can be cast in a more convenient form as:
\begin_inset Formula 
\begin{equation}
\frac{\partial\mathbf{q}}{\partial t}+\frac{\partial\mathbf{f}}{\partial x}+\frac{\partial\mathbf{h}}{\partial z}=\mathbf{s}\label{eq:dynamics_definition}
\end{equation}

\end_inset


\end_layout

\begin_layout Subsection
Maintaining Hydrostatic Balance
\end_layout

\begin_layout Standard
The flows this code simulates are relatively small perturbations off of
 a 
\begin_inset Quotes eld
\end_inset

hydrostatic
\begin_inset Quotes erd
\end_inset

 balance, which balances gravity with a difference in pressure:
\begin_inset Formula 
\[
\frac{dp}{dz}=-\rho g
\]

\end_inset

Because small violations of this balance lead to significant noise in the
 vertical momentum, it's best not to try to directly reconstruct this balance
 but rather to only reconstruct the perturbations.
 Therefore, hydrostasis is subtracted from (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:equations_spelled_out"

\end_inset

) to give:
\begin_inset Formula 
\begin{equation}
\frac{\partial}{\partial t}\left[\begin{array}{c}
\rho^{\prime}\\
\rho u\\
\rho w\\
\left(\rho\theta\right)^{\prime}
\end{array}\right]+\frac{\partial}{\partial x}\left[\begin{array}{c}
\rho u\\
\rho u^{2}+p\\
\rho uw\\
\rho u\theta
\end{array}\right]+\frac{\partial}{\partial z}\left[\begin{array}{c}
\rho w\\
\rho wu\\
\rho w^{2}+p^{\prime}\\
\rho w\theta
\end{array}\right]=\left[\begin{array}{c}
0\\
0\\
-\rho^{\prime}g\\
0
\end{array}\right]\label{eq:equations_spelled_out_no_hydrostasis}
\end{equation}

\end_inset

where a 
\begin_inset Quotes eld
\end_inset

prime
\begin_inset Quotes erd
\end_inset

 quantity represents that variable with the hydrostatic background state
 subtracted off.
\end_layout

\begin_layout Subsection
Dimensional Splitting
\end_layout

\begin_layout Standard
This equation is solved using dimensional splitting for simplicity and speed.
 The equations are split into 
\begin_inset Formula $x$
\end_inset

- and 
\begin_inset Formula $z$
\end_inset

-direction solves that are, respectively:
\begin_inset Formula 
\[
x:\,\,\,\,\,\,\,\,\,\,\frac{\partial\mathbf{q}}{\partial t}+\frac{\partial\mathbf{f}}{\partial x}=\mathbf{0}
\]

\end_inset


\begin_inset Formula 
\[
z:\,\,\,\,\,\,\,\,\,\,\frac{\partial\mathbf{q}}{\partial t}+\frac{\partial\mathbf{h}}{\partial x}=\mathbf{s}
\]

\end_inset

Each time step, the order in which the dimensions are solved is reversed,
 giving second-order accuracy overall.
 
\end_layout

\begin_layout Subsection
Finite-Volume Spatial Discretization
\begin_inset CommandInset label
LatexCommand label
name "subsec:Finite-Volume-Spatial-Discretiza"

\end_inset


\end_layout

\begin_layout Standard
A Finite-Volume discretization is used in which the PDE in a given dimension
 is integrated over a cell domain, 
\begin_inset Formula $\Omega_{i}\in\left[x_{i-1/2},x_{i+1/2}\right]$
\end_inset

, where 
\begin_inset Formula $x_{i\pm1/2}=x_{i}\pm\Delta x$
\end_inset

, 
\begin_inset Formula $x_{i}$
\end_inset

 is the cell center, and 
\begin_inset Formula $\Delta x$
\end_inset

 is the width of the cell.
 The integration is the same in the 
\begin_inset Formula $z$
\end_inset

-direction.
 Using the Gauss divergence theorem, this turns the equation into (using
 the 
\begin_inset Formula $z$
\end_inset

-direction as an example):
\begin_inset Formula 
\begin{equation}
\frac{\partial\overline{\mathbf{q}}_{i,k}}{\partial t}=-\frac{\mathbf{h}_{i,k+1/2}-\mathbf{h}_{i,k-1/2}}{\Delta z}+\overline{\mathbf{s}}_{i,k}\label{eq:fv_discretization}
\end{equation}

\end_inset

where 
\begin_inset Formula $\overline{\mathbf{q}}_{i,k}$
\end_inset

 and 
\begin_inset Formula $\overline{\mathbf{s}}_{i,k}$
\end_inset

 are the cell-average of the fluid state and source term over the cell of
 index 
\begin_inset Formula $i,k$
\end_inset

.
\end_layout

\begin_layout Standard
To compute the update one needs the flux vector at the cell interfaces and
 the cell-averaged source term.
 To compute the flux vector at interfaces, fourth-order-accurate polynomial
 interpolation is used using the four cell averages surrounding the cell
 interface in question.
\end_layout

\begin_layout Subsection
Runge-Kutta Time Integration
\end_layout

\begin_layout Standard
The equation (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:fv_discretization"

\end_inset

) still has a time derivative that needs integrating, and a simple low-storage
 Runge-Kutta ODE solver is used to integrate the time derivative, and it
 is solved as follows:
\begin_inset Formula 
\[
\mathbf{q}^{\star}=\mathbf{q}^{n}+\frac{\Delta t}{3}RHS\left(\mathbf{q}^{n}\right)
\]

\end_inset


\begin_inset Formula 
\[
\mathbf{q}^{\star\star}=\mathbf{q}^{n}+\frac{\Delta t}{2}RHS\left(\mathbf{q}^{\star}\right)
\]

\end_inset


\begin_inset Formula 
\[
\mathbf{q}^{n+1}=\mathbf{q}^{n}+\Delta tRHS\left(\mathbf{q}^{\star\star}\right)
\]

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset Quotes eld
\end_inset

Hyper-viscosity
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
The centered fourth-order discretization in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Finite-Volume-Spatial-Discretiza"

\end_inset

 is unstable as is and requires extra dissipation to damp out small-wavelength
 energy that would otherwise blow up the simulation.
 This damping is accomplished with a scale-selective fourth-order so-called
 
\begin_inset Quotes eld
\end_inset

hyper
\begin_inset Quotes erd
\end_inset

-viscosity that is defined as:
\begin_inset Formula 
\[
\frac{\partial\mathbf{q}}{\partial t}+\frac{\partial}{\partial x}\left(-\kappa\frac{\partial^{3}\mathbf{q}}{\partial x^{3}}\right)=\mathbf{0}
\]

\end_inset

and this is also solved with the Finite-Volume method just like above.
 The hyperviscosity constant is defined as:
\begin_inset Formula 
\[
\kappa=-\beta\left(\Delta x\right)^{4}2^{-4}\left(\Delta t\right)^{-1}
\]

\end_inset

where 
\begin_inset Formula $\beta\in\left[0,1\right]$
\end_inset

 is a user-defined parameter to control the strength of the diffusion, where
 a higher value gives more diffusion.
 
\end_layout

\end_body
\end_document
